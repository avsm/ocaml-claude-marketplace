# Vulnerability Classes Reference

Comprehensive patterns for testing each vulnerability class. Use this when auditing a specific type of vulnerability.

## Table of Contents

1. [Integer Vulnerabilities](#integer-vulnerabilities)
2. [Buffer Vulnerabilities](#buffer-vulnerabilities)
3. [Denial of Service](#denial-of-service)
4. [Cryptographic Vulnerabilities](#cryptographic-vulnerabilities)
5. [Injection Vulnerabilities](#injection-vulnerabilities)
6. [Path Traversal](#path-traversal)
7. [Race Conditions](#race-conditions)
8. [Memory Safety](#memory-safety)

---

## Integer Vulnerabilities

### Integer Overflow in Size Calculations

**CVE examples:**
- CVE-2015-8126 (libpng): Integer overflow in PNG row_info calculation
- CVE-2018-16435 (lcms): Integer overflow in AllocateDataSet
- CVE-2022-37434 (zlib): Heap buffer overflow via large gzip header

**Test pattern:**

```ocaml
(** Test overflow in width * height * bpp calculation. *)
let test_image_size_overflow () =
  (* Each multiplication step can overflow *)
  let cases = [
    (* width, height, bpp - any product overflows *)
    (Int.max_int, 1, 1);
    (1, Int.max_int, 1);
    (65536, 65536, 4);       (* 2^32 * 4 overflows 64-bit *)
    (0x10000, 0x10000, 1);   (* 2^32 overflows on 32-bit *)
  ] in
  List.iter (fun (w, h, bpp) ->
    match Image.create ~width:w ~height:h ~bpp with
    | Error _ -> ()
    | Ok _ -> Alcotest.failf "should reject %d x %d x %d" w h bpp
  ) cases

(** Test overflow in offset calculations. *)
let test_offset_overflow () =
  (* base + offset can overflow *)
  let base = Int.max_int - 10 in
  let offset = 100 in
  match Parser.read_at ~base ~offset with
  | Error `Overflow -> ()
  | _ -> Alcotest.fail "should detect offset overflow"
```

### Signed/Unsigned Confusion

**CVE examples:**
- CVE-2006-3459 (libtiff): Signed integer converted to size_t
- CVE-2012-2806 (libjpeg-turbo): Signed length treated as unsigned

**Test pattern:**

```ocaml
(** Test negative value interpreted as large unsigned. *)
let test_signed_unsigned_confusion () =
  (* 0xFFFFFFFF as int32 is -1, but could be interpreted as huge length *)
  let cases = [
    (-1l);          (* 0xFFFFFFFF *)
    (-2147483648l); (* 0x80000000 - min int32 *)
    (-100l);
  ] in
  List.iter (fun length_field ->
    let buf = Bytes.create 4 in
    Bytes.set_int32_be buf 0 length_field;
    match Parser.read_with_length buf with
    | Error _ -> ()
    | Ok _ -> Alcotest.failf "should reject length %ld" length_field
  ) cases
```

### Integer Truncation

**Test pattern:**

```ocaml
(** Test truncation when casting to smaller type. *)
let test_int64_truncation () =
  (* Value that fits in int64 but not int *)
  let large = 0x1_0000_0000L in  (* 2^32 *)
  match Parser.decode_length large with
  | Error `Length_too_large -> ()
  | _ -> Alcotest.fail "should reject length > max_int"
```

---

## Buffer Vulnerabilities

### Out-of-Bounds Read

**CVE examples:**
- CVE-2016-2842 (OpenSSL): OOB read in ASN.1 parsing
- CVE-2019-9956 (libjpeg): OOB read in cjpeg

**Test pattern:**

```ocaml
(** Test OOB read when length exceeds data. *)
let test_oob_read () =
  let make_truncated ~claimed ~actual =
    let header = Bytes.create 4 in
    Bytes.set_int32_be header 0 (Int32.of_int claimed);
    let body = Bytes.make actual '\x00' in
    Bytes.cat header body
  in
  let cases = [
    (100, 10);   (* Claims 100, has 10 *)
    (1, 0);      (* Claims 1, has 0 *)
    (1000000, 100);
  ] in
  List.iter (fun (claimed, actual) ->
    let data = make_truncated ~claimed ~actual in
    match Parser.decode data with
    | Error (`Truncated _) -> ()
    | Error _ -> ()
    | Ok _ -> Alcotest.failf "should reject claimed=%d actual=%d" claimed actual
  ) cases
```

### Buffer Over-read via Format String

**Test pattern:**

```ocaml
(** Test format string handling in error messages. *)
let test_format_strings () =
  let malicious = [
    "%s%s%s%s%s";
    "%n%n%n%n";
    "%x" ^ String.make 1000 '%';
  ] in
  List.iter (fun input ->
    (* Should not crash or leak info *)
    let _ = Parser.decode input in ()
  ) malicious
```

---

## Denial of Service

### Stack Exhaustion via Deep Nesting

**CVE examples:**
- CVE-2022-31116 (ujson): Stack buffer overflow via nested arrays
- CVE-2019-1010266 (lodash): Deep recursion in merge

**Test pattern:**

```ocaml
(** Test stack exhaustion via deep nesting. *)
let test_deep_nesting () =
  let depths = [100; 1000; 10000; 100000] in
  List.iter (fun depth ->
    let nested =
      String.concat "" (List.init depth (fun _ -> "{\"a\":")) ^
      "1" ^
      String.concat "" (List.init depth (fun _ -> "}"))
    in
    match Json.parse nested with
    | Error _ -> ()  (* Rejected is fine *)
    | Ok _ ->
        if depth > 1000 then
          Alcotest.failf "accepted nesting depth %d" depth
  ) depths
```

### Memory Exhaustion

**CVE examples:**
- CVE-2019-17498 (libssh2): Huge malloc via unchecked length
- CVE-2020-11080 (nghttp2): Huge allocation via SETTINGS frame

**Test pattern:**

```ocaml
(** Test memory exhaustion via huge allocation request. *)
let test_huge_allocation () =
  let huge_lengths = [
    0x7FFFFFFF;     (* Max int32 *)
    0x7FFFFFFE;
    100_000_000;
  ] in
  List.iter (fun length ->
    let buf = Bytes.create 4 in
    Bytes.set_int32_be buf 0 (Int32.of_int length);
    match Parser.decode buf with
    | Error _ -> ()
    | Ok _ -> Alcotest.failf "should reject length %d" length
  ) huge_lengths
```

### Billion Laughs (Entity Expansion)

**CVE examples:**
- CVE-2003-1564 (libxml2): Exponential entity expansion
- CVE-2019-12900 (bzip2): Decompression bomb

**Test pattern:**

```ocaml
(** Test exponential expansion in XML entities. *)
let test_billion_laughs () =
  let payload = {|<?xml version="1.0"?>
<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
  <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
]>
<lolz>&lol4;</lolz>|} in
  match Xml.parse payload with
  | Error _ -> ()
  | Ok _ -> Alcotest.fail "should reject entity expansion bomb"

(** Test decompression bomb. *)
let test_decompression_bomb () =
  (* Small compressed data that expands hugely *)
  let bomb = Bytes.of_string "\x78\x9c\xed\xc1\x01\x01\x00\x00..." in
  match Compression.decompress ~max_output:10_000_000 bomb with
  | Error (`Output_too_large _) -> ()
  | Error _ -> ()
  | Ok data ->
      if Bytes.length data > 10_000_000 then
        Alcotest.fail "decompression exceeded limit"
```

### Hash Collision DoS

**CVE examples:**
- CVE-2011-4815 (Ruby): Hash collision DoS
- CVE-2012-0876 (libexpat): Hash collision in DTD parsing

**Test pattern:**

```ocaml
(** Test hash collision resistance.
    Generate keys that collide in common hash functions. *)
let test_hash_collision_dos () =
  (* These strings may collide in Java String.hashCode-style hashes *)
  let collision_keys = [
    "Aa"; "BB";  (* Classic collision pair *)
    "AaAa"; "AaBB"; "BBAa"; "BBBB";
  ] in
  let start = Unix.gettimeofday () in
  let map = List.fold_left (fun m k ->
    String.Map.add k () m
  ) String.Map.empty collision_keys in
  let elapsed = Unix.gettimeofday () -. start in
  ignore map;
  (* Should be fast even with collisions if using randomized hashing *)
  if elapsed > 0.1 then
    Alcotest.fail "hash operations too slow - possible collision issue"
```

---

## Cryptographic Vulnerabilities

### Timing Side Channels

**CVE examples:**
- CVE-2016-0777 (OpenSSH): Timing attack on private key
- CVE-2018-12404 (NSS): Cache timing attack on RSA

**Test pattern:**

```ocaml
(** Verify constant-time comparison is used for MACs. *)
let test_mac_timing () =
  let correct_mac = Crypto.mac ~key "message" in
  let wrong_macs = [
    (* Differ in first byte *)
    Bytes.cat (Bytes.make 1 '\x00') (Bytes.sub correct_mac 1 (Bytes.length correct_mac - 1));
    (* Differ in last byte *)
    Bytes.cat (Bytes.sub correct_mac 0 (Bytes.length correct_mac - 1)) (Bytes.make 1 '\x00');
    (* All wrong *)
    Bytes.make (Bytes.length correct_mac) '\x00';
  ] in
  let measure_verify mac =
    let start = Sys.time () in
    for _ = 1 to 10000 do
      ignore (Auth.verify ~key ~mac "message")
    done;
    Sys.time () -. start
  in
  let times = List.map measure_verify wrong_macs in
  let variance = (* calculate variance *) 0.0 in
  (* Times should be similar regardless of which byte differs *)
  if variance > 0.01 then
    Alcotest.fail "MAC verification timing varies with input"
```

### Insufficient Randomness

**Test pattern:**

```ocaml
(** Test that random values have sufficient entropy. *)
let test_random_entropy () =
  let samples = List.init 1000 (fun _ -> Crypto.random_bytes 16) in
  (* Check no duplicates *)
  let unique = List.sort_uniq Bytes.compare samples in
  if List.length unique < List.length samples then
    Alcotest.fail "duplicate random values generated";
  (* Check distribution *)
  let all_bytes = Bytes.concat Bytes.empty samples in
  let counts = Array.make 256 0 in
  Bytes.iter (fun c -> counts.(Char.code c) <- counts.(Char.code c) + 1) all_bytes;
  let expected = Bytes.length all_bytes / 256 in
  let max_deviation = Array.fold_left (fun acc c ->
    max acc (abs (c - expected))
  ) 0 counts in
  if max_deviation > expected / 2 then
    Alcotest.fail "random byte distribution non-uniform"
```

### Padding Oracle

**CVE examples:**
- CVE-2016-2107 (OpenSSL): AES-NI padding oracle
- CVE-2019-1559 (OpenSSL): 0-byte record padding oracle

**Test pattern:**

```ocaml
(** Test that decryption errors don't leak padding info. *)
let test_padding_oracle () =
  let ciphertext = Crypto.encrypt ~key plaintext in
  let corrupt_positions = [
    Bytes.length ciphertext - 1;  (* Last byte - padding *)
    Bytes.length ciphertext - 16; (* First byte of last block *)
    0;                            (* IV byte *)
  ] in
  let times = List.map (fun pos ->
    let corrupted = Bytes.copy ciphertext in
    Bytes.set corrupted pos '\x00';
    let start = Sys.time () in
    for _ = 1 to 1000 do
      ignore (Crypto.decrypt ~key corrupted)
    done;
    Sys.time () -. start
  ) corrupt_positions in
  (* All corruption positions should have similar timing *)
  let max_diff = (* calculate max difference *) 0.0 in
  if max_diff > 0.01 then
    Alcotest.fail "decryption timing varies with corruption position"
```

---

## Injection Vulnerabilities

### Command Injection

**Test pattern:**

```ocaml
(** Test command injection in shell calls. *)
let test_command_injection () =
  let malicious_inputs = [
    "; rm -rf /";
    "| cat /etc/passwd";
    "$(whoami)";
    "`id`";
    "foo\nbar";
    "'; DROP TABLE users; --";
  ] in
  List.iter (fun input ->
    (* Function should either escape properly or reject *)
    match Command.run_with_arg input with
    | Error `Invalid_argument -> ()
    | Ok output ->
        if String.contains output '/' then
          Alcotest.failf "possible injection with: %S" input
  ) malicious_inputs
```

### Path Injection

**Test pattern:**

```ocaml
(** Test path traversal. *)
let test_path_traversal () =
  let malicious_paths = [
    "../../../etc/passwd";
    "..\\..\\..\\windows\\system32\\config\\sam";
    "....//....//etc/passwd";
    "foo/./bar/../../../etc/passwd";
    "/etc/passwd";
    "\\\\server\\share";
  ] in
  List.iter (fun path ->
    match Filestore.resolve ~root:"/safe/root" path with
    | Error `Path_traversal -> ()
    | Ok resolved ->
        if not (String.starts_with ~prefix:"/safe/root/" resolved) then
          Alcotest.failf "path escaped root: %S -> %S" path resolved
  ) malicious_paths
```

---

## Path Traversal

**CVE examples:**
- CVE-2018-1000001 (glibc): realpath buffer underflow via ".."
- CVE-2021-21300 (git): Pathname traversal in checkout

**Test pattern:**

```ocaml
(** Comprehensive path traversal tests. *)
let test_path_traversal_comprehensive () =
  let cases = [
    (* Basic traversal *)
    ("../secret", false);
    ("foo/../bar", true);  (* Stays within root *)
    ("foo/../../bar", false);

    (* Encoded traversal *)
    ("..%2f..%2fetc/passwd", false);
    ("..%252f..%252fetc/passwd", false);

    (* Unicode normalization attacks *)
    ("..ï¼secret", false);  (* Fullwidth solidus *)

    (* Null byte injection *)
    ("valid.txt\x00../secret", false);

    (* Symlink escape (if applicable) *)
    ("symlink/../../../etc/passwd", false);
  ] in
  List.iter (fun (path, should_allow) ->
    match Filestore.safe_join ~root:"/app/data" path with
    | Ok _ when should_allow -> ()
    | Error _ when not should_allow -> ()
    | Ok resolved -> Alcotest.failf "should reject: %S -> %S" path resolved
    | Error _ -> Alcotest.failf "should allow: %S" path
  ) cases
```

---

## Race Conditions

### TOCTOU (Time-of-check to Time-of-use)

**CVE examples:**
- CVE-2016-4989 (setroubleshoot): TOCTOU race in file operations
- CVE-2019-18276 (bash): TOCTOU in file descriptor handling

**Test pattern:**

```ocaml
(** Test TOCTOU in file operations.
    The check and use should be atomic. *)
let test_toctou () =
  let temp_file = Filename.temp_file "test" ".txt" in
  (* Create file *)
  let oc = open_out temp_file in
  output_string oc "content";
  close_out oc;
  (* In a real test, would have concurrent thread delete the file
     between check and use. Here we just verify the API is safe. *)
  match Filestore.read_if_exists temp_file with
  | `Not_found -> ()  (* File was deleted - OK *)
  | `Content s ->
      (* Verify content matches expectation *)
      Alcotest.(check string) "content" "content" s
  | `Error _ -> ()  (* Race detected and handled - OK *)
```

---

## Memory Safety

### Use After Free

Not typically applicable to OCaml due to GC, but relevant when using C bindings.

**Test pattern:**

```ocaml
(** Test that C bindings don't expose use-after-free. *)
let test_uaf_in_bindings () =
  let handle = External.create () in
  External.close handle;
  (* Subsequent operations should fail cleanly *)
  match External.use handle with
  | Error `Handle_closed -> ()
  | Error _ -> ()
  | Ok _ -> Alcotest.fail "used closed handle"
```

### Double Free

**Test pattern:**

```ocaml
(** Test that double-close is handled. *)
let test_double_free () =
  let handle = External.create () in
  External.close handle;
  (* Second close should not crash or corrupt *)
  External.close handle;  (* Should be no-op or error, not crash *)
  ()
```

---

## OCaml-Specific Considerations

### Safe vs Unsafe String Functions

```ocaml
(** Audit: Check for unsafe string operations. *)
(* AVOID: String.get without bounds check in tight loops *)
(* PREFER: String.sub with explicit bounds *)

(** Test bounds checking in string operations. *)
let test_string_bounds () =
  let test_get s i =
    match String.get s i with
    | _ -> `Ok
    | exception Invalid_argument _ -> `Bounds_error
  in
  Alcotest.(check (testable Fmt.string (=))) "empty[0]"
    `Bounds_error (test_get "" 0);
  Alcotest.(check (testable Fmt.string (=))) "abc[-1]"
    `Bounds_error (test_get "abc" (-1));
  Alcotest.(check (testable Fmt.string (=))) "abc[3]"
    `Bounds_error (test_get "abc" 3)
```

### Bigarrays and C Interop

```ocaml
(** Test bigarray operations at boundaries. *)
let test_bigarray_bounds () =
  let ba = Bigarray.Array1.create Bigarray.Int8_unsigned Bigarray.c_layout 10 in
  let test_set i v =
    match Bigarray.Array1.set ba i v with
    | () -> `Ok
    | exception Invalid_argument _ -> `Bounds_error
  in
  Alcotest.(check (testable Fmt.string (=))) "ba[-1]"
    `Bounds_error (test_set (-1) 0);
  Alcotest.(check (testable Fmt.string (=))) "ba[10]"
    `Bounds_error (test_set 10 0)
```
